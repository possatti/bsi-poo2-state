{"name":"Exemplo do padrão State em C++","tagline":"","body":"## Descrição do padrão\r\nO padrão permite a um objeto alterar o seu comportamento quando o estado interno muda. Para implementa-lo, uma das possibilidades é encapsularmos o estado em seu seu contexto. Conforme a estrutura do exemplo abaixo.\r\n\r\n![Estrutura do padrão State](http://sourcemaking.com/files/v2/content/patterns/State1-2x.png)\r\n\r\nNa figura acima podemos ver que `State` define uma interface comum para os estados, possibilitando que todos eles sejam usados, sem distinção, pelos clientes. Com isso, ele define o método `goNext(..)`, que é implementado pelas subclasses para ativar o próximo estado.\r\n\r\nPorém no caso da implementação do nosso exemplo, faremos um pouco diferente do descrito acima. Pois iremos implementar o cliente e o contexto como uma única entidade, para simplificar a implementação.\r\n\r\n## Implementação do exemplo\r\n\r\nNesse exemplo, tempos o caso de uma pizza, que pode estar em três diferentes estados: cooked (preparada), baked (assada), delivered (entregue). E dependendo das ações tomadas, a pizza muda o seu estado atual. Passando a responder de uma forma diferente.\r\n\r\nNo código, temos a classe `PizzaState` que é a classe base para os diferentes estados que serão implementados.\r\n\r\n**PizzaState.h:**\r\n```cpp\r\nclass Pizza;\r\n\r\nclass PizzaState\r\n{\r\npublic:\r\n    PizzaState();\r\n    virtual void bake(Pizza* pizza) const = 0;\r\n    virtual void deliver(Pizza* pizza) const = 0;\r\n    virtual ~PizzaState();\r\n};\r\n```\r\n\r\n**PizzaState.cpp:**\r\n```cpp\r\nPizzaState::PizzaState() { }\r\nPizzaState::~PizzaState() { }\r\n```\r\n\r\nVemos em `PizzaState` que definimos os métodos `bake(..)` e `deliver(..)` que não são implementados nessa classe. Mas são implementados nas subclasses (os diferentes estados).\r\n\r\nCom isso definido, nós implementamos as subclasses `CookedPizzaState`, `BakedPizzaState` e `DeliveredState`. Como exemplo, iremos exibir aqui, apenas a classe `BakedPizzaState`.\r\n\r\n\r\n**BakedPizzaState.h:**\r\n```cpp\r\n#include \"PizzaState.h\"\r\n\r\nclass Pizza;\r\n\r\nclass BakedPizzaState : public PizzaState\r\n{\r\npublic:\r\n    BakedPizzaState();\r\n    virtual void bake(Pizza* pizza) const;\r\n    virtual void deliver(Pizza* pizza) const;\r\n    virtual ~BakedPizzaState();\r\n};\r\n```\r\n\r\n**BakedPizzaState.cpp:**\r\n```cpp\r\n#include \"BakedPizzaState.h\"\r\n#include \"Pizza.h\"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nBakedPizzaState::BakedPizzaState() { }\r\n\r\nvoid BakedPizzaState::bake(Pizza* pizza) const\r\n{\r\n    cout << \"Can't bake a pizza already baked\" << endl;\r\n}\r\n\r\nvoid BakedPizzaState::deliver(Pizza* pizza) const\r\n{\r\n    cout << \"Delivering the pizza...\" << endl;\r\n    pizza->setState(pizza->getDeliveredState());\r\n}\r\n\r\nBakedPizzaState::~BakedPizzaState() { }\r\n```\r\n\r\nPodemos ver que em `BakedPizzaState`, nós implementamos os métodos `bake(..)` e `deliver(..)` da classe `PizzaState` para desempenhar o comportamento específico de um pizza quando ela está no estado `BakedPizzaState`.\r\n\r\nAgora precisamos ver como a pizza usa esses estados. Basicamente o que a classe `Pizza` faz é delegar a chamada de seus métodos para os métodos do estado, ao invés de responder por si mesma. Como por exemplo, ao chamar o método `pizza->deliver(..)`, esse método da pizza, irá encaminhar a respota do seu estado atual: `currentState->deliver(..)`.\r\n\r\nAgora vejamos a implementação da pizza.\r\n\r\n**Pizza.h:**\r\n```cpp\r\n#include \"PizzaState.h\"\r\n\r\nclass PizzaState;\r\n\r\nclass Pizza\r\n{\r\nprivate:\r\n    const PizzaState * const cookedState;\r\n    const PizzaState * const bakedState;\r\n    const PizzaState * const deliveredState;\r\n    const PizzaState *state; // Estado atual.\r\npublic:\r\n    Pizza();\r\n    const PizzaState* getCookedState();\r\n    const PizzaState* getBakedState();\r\n    const PizzaState* getDeliveredState();\r\n    void bake();\r\n    void deliver();\r\n    void setState(const PizzaState* state);\r\n    virtual ~Pizza();\r\n};\r\n```\r\n\r\n**Pizza.cpp:**\r\n```cpp\r\n#include \"Pizza.h\"\r\n#include \"CookedPizzaState.h\"\r\n#include \"BakedPizzaState.h\"\r\n#include \"DeliveredState.h\"\r\n\r\nPizza::Pizza() :\r\ncookedState(new CookedPizzaState()),\r\nbakedState(new BakedPizzaState()),\r\ndeliveredState(new DeliveredState())\r\n{ this->state = cookedState; }\r\n\r\nvoid Pizza::bake()\r\n{ this->state->bake(this); }\r\n\r\nvoid Pizza::deliver()\r\n{ this->state->deliver(this); }\r\n\r\nconst PizzaState* Pizza::getBakedState()\r\n{ return this->bakedState; }\r\n\r\nconst PizzaState* Pizza::getDeliveredState()\r\n{ return this->deliveredState; }\r\n\r\nconst PizzaState* Pizza::getCookedState()\r\n{ return this->cookedState; }\r\n\r\nvoid Pizza::setState(const PizzaState* state)\r\n{ this->state = state; }\r\n\r\nPizza::~Pizza() { }\r\n```\r\n\r\nNo código, vemos claramente que os métodos encaminham a responsabilidade para os métodos do estado atual, e eles devem dar conta de responder achamada e mudar de estado quando for necessário.\r\n\r\nPor fim, vejamos o `main` exemplificando o uso da classe pizza.\r\n\r\n**main.cpp:**\r\n```cpp\r\n#include <cstdlib>\r\n\r\n#include \"Pizza.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char** argv)\r\n{\r\n\t// Cria uma pizza.\r\n    Pizza* pizza = new Pizza;\r\n\r\n    // Faz várias chamadas dos métodos da pizza.\r\n    pizza->deliver();\r\n    pizza->bake();\r\n    pizza->bake();\r\n    pizza->deliver();\r\n    pizza->deliver();\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n## Alunos\r\n - Lucas Possatti (@possatti)\r\n - Phillipe Alcantara (@paflopes)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}